import { Router } from '@angular/router';
import { RESTAPIService } from './REST-API.service';
import { NotificationConfiguration } from '../models/notification.model';
import * as moment from 'moment';
import { forkJoin } from 'rxjs';
import { ToastrService } from 'ngx-toastr';
import { AppConstants } from '../AppConstants';
import { CommonService } from './common.service';
import { AutoGeneratedEmailService } from './autogeneratedemails-service';
import { IGeneric } from '../services/IGeneric';

declare const _spPageContextInfo: any;

export class NotificationService implements IGeneric {
  userInfo: any = _spPageContextInfo;
  notificationType: any;
  notificationTypeData = [];
  onDemandListArr: any = [];
  siteAllUsers: any = [];
  onDemandEmail: AutoGeneratedEmailService;
  isCompleted = false;
  notificationArray = [];
  actionItem: any;
  index: number;
  actionItemsList: any[];
  projects: any;
  project: any;

  /*
   * typeValue = Notification Type (e.g. Assign To, Action Required, etc.)
   */
  constructor(
    public commonService: CommonService,
    private router: Router,
    private restAPIService: RESTAPIService,
    private toastr: ToastrService,
    private typeValue: string
  ) {

    this.onDemandEmail = new AutoGeneratedEmailService(this.restAPIService);

    this.restAPIService.getAllSiteUsers().subscribe(users => {
      this.siteAllUsers = users;
    });

    this.getNotificationType(this.typeValue);
  }

  /* This method first saves the notification record in the NotificationConfiguration SP list and then subsequently
   * saves any on demand email records in the AutoGeneratedEmailOnDemand SP list that need to go out immediately
   * parameters:
   * objectID = parent type object id (e.g. activity or action item id)
   * newTrackingItem = user updated tracking item - must be a valid array and not string format
   * mode = create, edit
   * typeValue = Notification Type (e.g. Assign To, Action Required, etc.)
   * objectType = parent type object (e.g. activity or action item)
   * title = activity, action item, etc. title
   * contractNo = project number
   * email = represents Assign To email and is only required when the typeValue field is 'Assign To'
   */

  saveNotificationRecord(
    objectID: number,
    newTrackingItem: any,
    mode: string,
    typeValue: any,
    objectType: any,
    title: string,
    description: string,
    contractNo: any,
    email: string) {
    // if (!this.commonService.isNotUndefinedNullOrEmpty(objectID) &&
    if (objectID > 0 &&
      !this.commonService.isNotUndefinedNullOrEmpty(typeValue) &&
      !this.commonService.isNotUndefinedNullOrEmpty(objectType) &&
      !this.commonService.isNotUndefinedNullOrEmpty(title) &&
      !this.commonService.isNotUndefinedNullOrEmpty(contractNo)) {
      console.log('All data parameters must not null, undefined, or empty. The save notification request has been aborted.');
      return;
    }

    // TODO - Sometimes the 'newTrackingItem' will be empty when saving a ASSIGN TO notification. Need to figure out how to validate that data parameter
    //       so we don't allow the system to store 'junk' that might come through.

    let notificationObj;
    let revisedNotificationObject: NotificationConfiguration;
    if (typeValue === AppConstants.ASSIGN_TO || typeValue === AppConstants.ASSIGN_TO_ACTION_ITEM) {
      notificationObj = new NotificationConfiguration({// Creating a new notification configuration object in parallel to pull from db/SP list at beginning of method
        ContractNo: contractNo,
        Title: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
        number: 0,
        trigger_type: AppConstants.TrackingItemCategoryOptions.BEFORE_SCHEDULED_DATE,
        isCurrentNotification: AppConstants.YES,
        Target: email,
        ReceiptDate: moment().format(AppConstants.AP3DateFormat),
        Due_Date: moment().format(AppConstants.AP3DateFormat),
        Types: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
        SubjectLine: '',
        Description: '',
        Subject: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.subject : this.notificationType.subject,
        Message: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.message : this.notificationType.message,
        NotificationTypeID: typeValue === AppConstants.ASSIGN_TO ? String(this.notificationType.notificationTypeID) : String(this.notificationType.notificationTypeID),
        // Priority: trackingItem.priority,,
        // Priority: trackingItem.priority,
        NotificationIdentifier: this.restAPIService.getUniqueId(),
        IsScheduled: AppConstants.NO,
        ParentType: objectType,
        ActivityTitle: title,
        ParentId: String(objectID)
      });

      // Persist notification into SP list
      this.persist(notificationObj);

    } else {
      // Create the notification record
      notificationObj = new NotificationConfiguration({
        ContractNo: contractNo,
        Title: this.notificationType.notificationType || '',
        number: newTrackingItem.numberOfDays,
        trigger_type: newTrackingItem.category,
        Target: newTrackingItem.email.toString(),
        ReceiptDate: newTrackingItem.actualReceiptDate,
        Types: typeValue || '',
        SubjectLine: newTrackingItem.itemDescription,
        Description: newTrackingItem.itemDescription,
        Due_Date: newTrackingItem.scheduledDate,
        Subject: this.notificationType.subject || '',
        Message: this.notificationType.message || '',
        NotificationTypeID: String(this.notificationType.notificationTypeID) || '',
        NotificationIdentifier: this.commonService.isNotUndefinedNullOrEmpty(newTrackingItem.NotificationIdentifier) ? newTrackingItem.NotificationIdentifier : this.restAPIService.getUniqueId(),
        IsScheduled: newTrackingItem.isScheduled,
        ParentType: objectType,
        ActivityTitle: title,
        ParentId: String(objectID)
      });

      // Identifiy notifications that need to go out today
      if (mode === 'create') {
        revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, true);
      } else if (mode === 'edit') {
        revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, false);
      }
      this.persist(revisedNotificationObject);
    }

    // check to see if this notification obj was put on the onDemandArr to go out today
    if (this.onDemandListArr.length > 0) {
      const sendEmailObj: any = {};
      sendEmailObj.Title = typeValue;
      sendEmailObj.ContractNo = contractNo;
      sendEmailObj.WorkItemId = String(objectID);
      sendEmailObj.ObjectTitle = title;
      sendEmailObj.ObjectDescription = description;
      sendEmailObj.ActivityType = typeValue;

      if (objectType === AppConstants.ACTIVITY_TYPE) {
        sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + String(objectID) + '?mode=edit';
      } else if (objectType === AppConstants.ACTION_ITEM_TYPE) {
        sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + String(objectID) + '&mode=edit';
      }

      sendEmailObj.RecipientsList = newTrackingItem.email.toString();
      sendEmailObj.ItemType = objectType;
      sendEmailObj.NotificationIdentifier = typeValue === AppConstants.ACTION_REQUIRED || typeValue === AppConstants.PROCESS_PR_TO_CONTRACTS ? revisedNotificationObject.NotificationIdentifier : notificationObj.NotificationIdentifier;
      sendEmailObj.__metadata = { type: 'SP.Data.AutoGeneratedEmailsOnDemandListItem' };

      // Submit to AutoGeneratedEmailsOnDemandListItem SP list
      this.onDemandEmail.persist(sendEmailObj);
    } else {
      console.log('Same day/immediate notifications are not required for the following item: ', revisedNotificationObject);
    }

    this.onDemandListArr = [];
  }

  /* This method first updates the notification record in the NotificationConfiguration SP list and then subsequently
   * saves any on demand email records in the AutoGeneratedEmailOnDemand SP list that need to go out immediately.
   * This method assumes that you are not sending an Assign To email since they are only sent out upon assignment OR unassignment and are not edited
   * parameters:
   * objectID = parent type object id (e.g. activity or action item id)
   * newTrackingItem = user updated tracking item
   * mode = create, edit
   * typeValue = Notification Type (e.g. Assign To, Action Required, etc.)
   * objectType = parent type object (e.g. activity or action item)
   * title = activity, action item, etc. title
   * contractNo = project number
  */
  updateNotficationRecord(objectID: any, newTrackingItem: any, trackingItemToBeUpdated: any, mode: string, typeValue: any, objectType: any, title: any, description: any, contractNo: any) {
    if (!this.commonService.isNotUndefinedNullOrEmpty(objectID) &&
      !this.commonService.isNotUndefinedNullOrEmpty(newTrackingItem) &&
      !this.commonService.isNotUndefinedNullOrEmpty(trackingItemToBeUpdated) &&
      !this.commonService.isNotUndefinedNullOrEmpty(typeValue) &&
      !this.commonService.isNotUndefinedNullOrEmpty(objectType) &&
      !this.commonService.isNotUndefinedNullOrEmpty(title) &&
      !this.commonService.isNotUndefinedNullOrEmpty(contractNo)) {
      console.log('All data parameters must not null, undefined, or empty. This update notification request has been aborted.');
      return;
    }

    // To block out empty notifications from being modified
    if (this.commonService.isNotUndefinedNullOrEmpty(newTrackingItem.trigger_type) ||
      this.commonService.isNotUndefinedNullOrEmpty(newTrackingItem.Target)) {
      return;
    }

    let notificationObj;
    let revisedNotificationObject: NotificationConfiguration;
    if (typeValue === AppConstants.ASSIGN_TO || typeValue === AppConstants.ASSIGN_TO_ACTION_ITEM) {
      notificationObj = new NotificationConfiguration({// Creating a new notification configuration object in parallel to pull from db/SP list at beginning of method
        ContractNo: contractNo,
        Title: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
        number: 0,
        trigger_type: AppConstants.TrackingItemCategoryOptions.BEFORE_SCHEDULED_DATE,
        isCurrentNotification: AppConstants.YES,
        Target: newTrackingItem.email.toString(),
        ReceiptDate: moment().format(AppConstants.AP3DateFormat),
        Due_Date: moment().format(AppConstants.AP3DateFormat),
        Types: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
        SubjectLine: '',
        Description: '',
        Subject: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.subject : this.notificationType.subject,
        Message: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.message : this.notificationType.message,
        NotificationTypeID: typeValue === AppConstants.ASSIGN_TO ? String(this.notificationType.notificationTypeID) : String(this.notificationType.notificationTypeID),
        // Priority: trackingItem.priority,,
        // Priority: trackingItem.priority,
        NotificationIdentifier: this.restAPIService.getUniqueId(),
        IsScheduled: AppConstants.NO,
        ParentType: objectType,
        ActivityTitle: title,
        ParentId: String(objectID)
      });

      // Persist notification into SP list
      this.persist(notificationObj);

    } else {
      // Create the notification record
      notificationObj = new NotificationConfiguration({
        ContractNo: contractNo,
        Title: this.notificationType.notificationType || '',
        number: newTrackingItem.numberOfDays,
        trigger_type: newTrackingItem.category,
        Target: newTrackingItem.email.toString(),
        ReceiptDate: newTrackingItem.actualReceiptDate,
        Types: typeValue || '',
        SubjectLine: newTrackingItem.itemDescription,
        Description: newTrackingItem.itemDescription,
        Due_Date: newTrackingItem.scheduledDate,
        Subject: this.notificationType.subject || '',
        Message: this.notificationType.message || '',
        NotificationTypeID: String(this.notificationType.notificationTypeID) || '',
        NotificationIdentifier: this.commonService.isNotUndefinedNullOrEmpty(newTrackingItem.NotificationIdentifier) ? newTrackingItem.NotificationIdentifier : this.restAPIService.getUniqueId(),
        IsScheduled: newTrackingItem.isScheduled,
        ParentType: objectType,
        ActivityTitle: title,
        ParentId: String(objectID)
      });

      // Identifiy notifications that need to go out today
      if (mode === 'create') {
        revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, true);
      } else if (mode === 'edit') {
        revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, false);
      }
      this.persist(revisedNotificationObject);
    }

    let notificationArray = [];
    this.restAPIService.getNotificationConfiguration().subscribe((response) => {
      if (this.restAPIService.isSuccessResponse(response)) {

        notificationArray = response.data;

        for (const iterator of notificationArray) {
          if (iterator.NotificationIdentifier === trackingItemToBeUpdated.NotificationIdentifier) {

            // If there have been no changes by the user go to the next item in the list
            if (newTrackingItem.trigger_type === iterator.trigger_type) {
              if (newTrackingItem.Due_Date === iterator.Due_Date) {
                if (newTrackingItem.Target === iterator.Target) {
                  if (parseInt(newTrackingItem.number, 10) === parseInt(iterator.number, 10)) {
                    break;
                  }
                }
              }
            }

            revisedNotificationObject.ID = iterator.ID;

            this.updateNotificationObj(revisedNotificationObject, iterator.ID, this.onDemandListArr);

            if (this.onDemandListArr.length > 0) {
              const sendEmailObj: any = {};
              sendEmailObj.Title = typeValue; // TODO - need to make this configurable in the future
              sendEmailObj.ContractNo = contractNo;
              sendEmailObj.WorkItemId = String(objectID);
              sendEmailObj.ObjectTitle = title;
              sendEmailObj.ObjectDescription = description;
              sendEmailObj.ActivityType = typeValue;

              if (objectType === AppConstants.ACTIVITY_TYPE) {
                sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + String(objectID) + '?mode=edit';
              } else if (objectType === AppConstants.ACTION_ITEM_TYPE) {
                sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + String(objectID) + '&mode=edit';
              }

              sendEmailObj.RecipientsList = newTrackingItem.email.toString();
              sendEmailObj.ItemType = objectType;
              sendEmailObj.NotificationIdentifier = revisedNotificationObject.NotificationIdentifier;
              sendEmailObj.__metadata = { type: 'SP.Data.AutoGeneratedEmailsOnDemandListItem' };

              // Submit to AutoGeneratedEmailsOnDemandListItem SP list
              this.onDemandEmail.persist(sendEmailObj);

              this.onDemandListArr = [];
            } else {
              console.log('Same day/immediate notifications are not required for the following item: ', revisedNotificationObject);
            }
          }
        }

      } else {
        console.log('findAll notification configuration API request was not successful.');
      }
    });
  }

  /* This method first updates the notification record in the NotificationConfiguration SP list and then subsequently
   * saves any on demand email records in the AutoGeneratedEmailOnDemand SP list that need to go out immediately
  */
  updateNotificationRecords(objectID: any, newTrackingItemArray: any[], mode: string, typeValue: any, objectType: any, title: any, description: any, contractNo: any) {
    if (!this.commonService.isNotUndefinedNullOrEmpty(objectID) &&
      newTrackingItemArray.length > 0 &&
      !this.commonService.isNotUndefinedNullOrEmpty(typeValue) &&
      !this.commonService.isNotUndefinedNullOrEmpty(objectType) &&
      !this.commonService.isNotUndefinedNullOrEmpty(title) &&
      !this.commonService.isNotUndefinedNullOrEmpty(contractNo)) {
      console.log('All data parameters must not null, undefined, or empty. This update notification request has been aborted.');
      return;
    }

    let notificationArray = [];
    this.restAPIService.getNotificationConfiguration().subscribe((response) => {
      if (this.restAPIService.isSuccessResponse(response)) {
        notificationArray = response.data;

        for (const iterator of newTrackingItemArray) {
          for (const counter of notificationArray) {
            if (iterator.NotificationIdentifier === counter.NotificationIdentifier) {

              // To block out empty notifications from being added
              // If there is no data in the array return
              if (!this.commonService.isNotUndefinedNullOrEmpty(iterator.category) || (iterator.email.length <= 0)) {
                break;
              }

              let notificationObj;
              let revisedNotificationObject: NotificationConfiguration;
              if (typeValue === AppConstants.ASSIGN_TO || typeValue === AppConstants.ASSIGN_TO_ACTION_ITEM) {
                notificationObj = new NotificationConfiguration({// Creating a new notification configuration object in parallel to pull from db/SP list at beginning of method
                  ContractNo: contractNo,
                  Title: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
                  number: 0,
                  trigger_type: AppConstants.TrackingItemCategoryOptions.BEFORE_SCHEDULED_DATE,
                  isCurrentNotification: AppConstants.YES,
                  Target: iterator.email.toString(),
                  ReceiptDate: moment().format(AppConstants.AP3DateFormat),
                  Due_Date: moment().format(AppConstants.AP3DateFormat),
                  Types: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.notificationType : this.notificationType.notificationType,
                  SubjectLine: '',
                  Description: '',
                  Subject: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.subject : this.notificationType.subject,
                  Message: typeValue === AppConstants.ASSIGN_TO ? this.notificationType.message : this.notificationType.message,
                  NotificationTypeID: typeValue === AppConstants.ASSIGN_TO ? String(this.notificationType.notificationTypeID) : String(this.notificationType.notificationTypeID),
                  // Priority: trackingItem.priority,,
                  // Priority: trackingItem.priority,
                  NotificationIdentifier: this.restAPIService.getUniqueId(),
                  IsScheduled: AppConstants.NO,
                  ParentType: objectType,
                  ActivityTitle: title,
                  ParentId: String(objectID)
                });

                // Persist notification into SP list
                this.updateNotificationObj(notificationObj, counter.ID, this.onDemandListArr);

              } else {
                // Create the notification record
                notificationObj = new NotificationConfiguration({
                  ContractNo: contractNo,
                  Title: this.notificationType.notificationType || '',
                  number: iterator.numberOfDays,
                  trigger_type: iterator.category,
                  Target: iterator.email.toString(),
                  ReceiptDate: iterator.actualReceiptDate,
                  Types: typeValue || '',
                  SubjectLine: iterator.itemDescription,
                  Description: iterator.itemDescription,
                  Due_Date: iterator.scheduledDate,
                  Subject: this.notificationType.subject || '',
                  Message: this.notificationType.message || '',
                  NotificationTypeID: String(this.notificationType.notificationTypeID) || '',
                  NotificationIdentifier: this.commonService.isNotUndefinedNullOrEmpty(iterator.NotificationIdentifier) ? iterator.NotificationIdentifier : this.restAPIService.getUniqueId(),
                  IsScheduled: iterator.isScheduled,
                  ParentType: objectType,
                  ActivityTitle: title,
                  ParentId: String(objectID)
                });

                // Identifiy notifications that need to go out today
                if (mode === 'create') {
                  revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, true);
                } else if (mode === 'edit') {
                  revisedNotificationObject = this.updateNotificationDateInfo(notificationObj, false);
                }
                this.updateNotificationObj(revisedNotificationObject, counter.ID, this.onDemandListArr);
              }

              if (this.onDemandListArr.length > 0) {
                const sendEmailObj: any = {};
                sendEmailObj.Title = typeValue;
                sendEmailObj.ContractNo = contractNo;
                sendEmailObj.WorkItemId = String(objectID);
                sendEmailObj.ObjectTitle = title;
                sendEmailObj.ObjectDescription = description;
                sendEmailObj.ActivityType = typeValue;

                if (objectType === AppConstants.ACTIVITY_TYPE) {
                  sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + String(objectID) + '?mode=edit';
                } else if (objectType === AppConstants.ACTION_ITEM_TYPE) {
                  sendEmailObj.URL = _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + String(objectID) + '&mode=edit';
                }

                sendEmailObj.RecipientsList = iterator.email.toString();
                sendEmailObj.ItemType = objectType;
                sendEmailObj.NotificationIdentifier = revisedNotificationObject.NotificationIdentifier;
                sendEmailObj.__metadata = { type: 'SP.Data.AutoGeneratedEmailsOnDemandListItem' };

                // Submit to AutoGeneratedEmailsOnDemandListItem SP list
                this.onDemandEmail.persist(sendEmailObj);

                this.onDemandListArr = [];
              } else {
                console.log('Same day/immediate notifications are not required for the following item: ', revisedNotificationObject);
              }
            }
          }
        }

      } else {
        console.log('findAll notification configuration API request was not successful.');
      }
    });
  }

  /*** Requires a valid notification object and an existing id value in order to update successfully */
  updateNotificationObj(object: any, id: any, onDemandArray: any[]): any {

    if (!this.commonService.isNotUndefinedNullOrEmpty(object)) {
      console.log('Object is not valid, is empty, or id < 0 for notification update process. Aborting request.');
      return;
    }

    this.restAPIService.updateNotificationConfiguration(object, id).subscribe(response => {
      if (this.restAPIService.isSuccessResponse(response)) {
        console.log('The following notification configuration item was successfully updated in the system:', response);
        this.restAPIService.notifyRefreshNotification();
        // Validate whether or not the toaster message should be displayed or not
        for (const iterator of onDemandArray) {
          if (iterator.NotificationIdentifier === object.NotificationIdentifier) {
            this.toastr.warning(object.Title);
          }
        }
      } else {
        console.log('update notification configuration API request was not successful.');
      }
    });
  }

  /**** Checks to see if this notification should go out today or if we should schedule it for later */
  updateNotificationDateInfo(notificationObj: any, isNew: boolean): any {
    if (notificationObj.number) {
      const momentToday = moment().startOf('day');
      if (isNew) {
        notificationObj.IsScheduled = 'No';
      }
      if (notificationObj.trigger_type === 'Before Due Date' || notificationObj.trigger_type === 'Before Scheduled Date') {
        const dueDate = moment(notificationObj.Due_Date, AppConstants.AP3DateFormat);
        notificationObj.Due_Date = notificationObj.number > 0 ? dueDate.subtract(notificationObj.number, 'day').format('MM-DD-YYYY') : notificationObj.Due_Date;
        notificationObj.number = notificationObj.number > 0 ? notificationObj.number : 0;
        // The purpose of the extra 'IsScheduled' field is to ensure that notifications slated to go out via the daily scheduled
        // service aren't sent out whenever a user arbitrarily adds another notification
        if (moment(notificationObj.Due_Date).isSame(momentToday) && notificationObj.IsScheduled === 'No') {
          notificationObj.IsNotificationSent = 'Yes';
          // set the IsScheduled value to 'Yes' to ensure that this doesn't go out again by accident later
          notificationObj.IsScheduled = 'Yes';
          // TODO - need to find a better way to do this - kinda wonky (maybe return a notification object and a boolean value? I dunno)
          this.onDemandListArr.push(notificationObj);
        } else {
          // set the IsScheduled value to 'Yes' to ensure that this doesn't go out again by accident later
          if (moment(notificationObj.Due_Date).isSame(momentToday) && notificationObj.IsScheduled === 'Yes') {
            notificationObj.IsScheduled = 'No';
            this.onDemandListArr.push(notificationObj);
          }
        }
      }
      else if (notificationObj.trigger_type === 'After Receipt Date') {
        const dueDate = moment(notificationObj.ReceiptDate, AppConstants.AP3DateFormat);
        notificationObj.ReceiptDate = notificationObj.number > 0 ? dueDate.add(notificationObj.number, 'day').format('MM-DD-YYYY') : notificationObj.Due_Date;
        notificationObj.number = notificationObj.number > 0 ? notificationObj.number : 0;
        if (moment(notificationObj.ReceiptDate).isSame(momentToday) && notificationObj.IsScheduled === 'No') {
          notificationObj.IsNotificationSent = 'Yes';
          // set the IsScheduled value to 'Yes' to ensure that this doesn't go out again by accident later
          notificationObj.IsScheduled = 'Yes';
          this.onDemandListArr.push(notificationObj);
        } else {
          // set the IsScheduled value to 'Yes' to ensure that this doesn't go out again by accident later
          if (moment(notificationObj.ReceiptDate).isSame(momentToday) && notificationObj.IsScheduled === 'Yes') {
            notificationObj.IsScheduled = 'No';
            this.onDemandListArr.push(notificationObj);
          }
        }
      }
      return notificationObj;
    }
  }

  // TODO - need parameter to number, test, and ensure that all methods that use it function properly
  deleteAllNotificationsForActivity(activityObjID: any) {
    // let notificationArray = this.findAll();
    this.restAPIService.getNotificationConfiguration().subscribe((response) => {
      if (this.restAPIService.isSuccessResponse(response)) {
        let notificationArray = [];
        notificationArray = response.data;
        for (const record of notificationArray) {
          // If activity id === parent id of a notification - delete it
          if (parseInt(record.ParentId, 10) === parseInt(activityObjID.ID, 10)) {
            this.deleteById(record.ID);
          }
        }
      } else {
        console.log('No notification configuration data was returned from server');
      }
    });
  }

  deleteAllNotificationsForActionItem(actionItemObjID: number) {
    // let notificationArray = this.findAll();
    this.restAPIService.getNotificationConfiguration().subscribe((response) => {
      if (this.restAPIService.isSuccessResponse(response)) {
        let notificationArray = [];
        notificationArray = response.data;
        for (const record of notificationArray) {
          // If activity id === parent id of a notification - delete it
          if (parseInt(record.ParentId, 10) === actionItemObjID) {
            this.deleteById(record.ID);
          }
        }
      } else {
        console.log('No notification configuration data was returned from server');
      }
    });
  }

  deleteNotificationByNotificationIdentifier(notificationIdentifier: string) {
    // let notificationArray = this.findAll();
    if (!this.commonService.isNotUndefinedNullOrEmpty(notificationIdentifier)) {
      return;
    }
    this.restAPIService.getNotificationConfiguration().subscribe((response) => {
      if (this.restAPIService.isSuccessResponse(response)) {
        let notificationArray = [];
        notificationArray = response.data;
        for (const record of notificationArray) {
          // If the user DOESN't provide the specific Notification Identifier number then don't delete anything - if they do then delete the requested record
          if (notificationIdentifier !== '') {
            if (record.NotificationIdentifier === notificationIdentifier) {
              this.deleteById(record.ID);
            }
          }
        }
      } else {
        console.log('No notification configuration data was returned from server');
      }
    });
  }

  /*** This method posts the assigned to email to the AutoGeneratedEmailsOnDemandList and also deletes the notification record on unassign
   * Specify mode = AppConstants.DELETE and only provide current 'assignedTo' user in order to send out unassign email when deleting an activity */
  postEmailsAndAddOrDeleteNotificaitonsForActivities(activityObj: any, assignedTo: string, originalAssginedTo: string, mode: string): void {
    // If a user was assigned this task post to 'AutoGeneratedEmailsOnDemandList'
    if (activityObj) {

      let assignedToUser: any;
      let originalAssignedToUser: any;

      // standardize the this.originalAssignedToUser and assignedTo values
      if (originalAssginedTo === null || originalAssginedTo === undefined) {
        originalAssginedTo = '';
      }

      if (assignedTo === null || assignedTo === undefined) {
        assignedTo = '';
      }

      // If both the assigned to and the original assigned user values are empty there are no notifications that need to go out
      if (assignedTo === '') {
        if (originalAssginedTo === '') {
          return;
        }
      }

      if (assignedTo === originalAssginedTo) {
        return;
      }

      // Get email address target information for all users
      if (assignedTo !== '') {
        assignedToUser = this.siteAllUsers.value.find(item => item.Title.toLowerCase() === assignedTo.toLowerCase());
      }

      if (originalAssginedTo !== '') {
        originalAssignedToUser = this.siteAllUsers.value.find(item => item.Title.toLowerCase() === originalAssginedTo.toLowerCase());
      }

      let assignToEmailObj;
      let unassignEmailObj;

      // If there is both an unassign to and an assign to
      if (originalAssginedTo !== '' && assignedTo !== '') {
        // Ensure that we have valid emails for both
        if (originalAssignedToUser && assignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out assigned to email
          assignToEmailObj = this.createSendEmailObject(
            assignedToUser.Email,
            AppConstants.ACTIVITY_TYPE,
            AppConstants.ASSIGN_TO,
            activityObj.Identifier,
            activityObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
            activityObj.Title,
            activityObj.Description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(assignToEmailObj);

          // send out unassigned to email
          unassignEmailObj = this.createSendEmailObject(
            originalAssignedToUser.Email,
            AppConstants.ACTIVITY_TYPE,
            AppConstants.UNASSIGN_TO,
            activityObj.Identifier,
            activityObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
            activityObj.Title,
            activityObj.Description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(unassignEmailObj);

          /**** Post new notification and delete old*/

          // Post assign to notification
          this.saveNotificationRecord(
            activityObj.ID,
            '',
            mode,
            AppConstants.ASSIGN_TO,
            AppConstants.ACTIVITY_TYPE, // TODO - need to make dynamic to support both activities and action items
            activityObj.Title,
            '', // there is no description in an activity
            activityObj.Identifier,
            assignedToUser.Email);


          // Remove old assigned to notification
          this.restAPIService.getNotificationConfiguration().subscribe((response) => {
            if (this.restAPIService.isSuccessResponse(response)) {
              let notificationArray = [];
              notificationArray = response.data;

              for (const record of notificationArray) {
                if (parseInt(record.ParentId, 10) === parseInt(activityObj.ID, 10)) {
                  if (record.Target === originalAssignedToUser.Email) {
                    this.deleteById(record.ID);
                  }
                }
              }
            } else {
              console.log('No notification configuration data was returned from server');
            }
          });
        } else {
          console.log('A valid email address is not available for both the ASSIGNED TO and UNASSIGNED TO users. Emails and notification functions will abort.');
        }
      } // if there is only an original assigned to user
      else if (originalAssginedTo !== '' && assignedTo === '') {
        // Ensure that we have valid email
        if (originalAssignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out unassigned to email
          unassignEmailObj = this.createSendEmailObject(
            originalAssignedToUser.Email,
            AppConstants.ACTIVITY_TYPE,
            AppConstants.UNASSIGN_TO,
            activityObj.Identifier,
            activityObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
            activityObj.Title,
            activityObj.Description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(unassignEmailObj);

          /**** Delete old notification*/

          // Remove old assigned to notification
          this.restAPIService.getNotificationConfiguration().subscribe((response) => {
            if (this.restAPIService.isSuccessResponse(response)) {
              let notificationArray = [];
              notificationArray = response.data;

              for (const record of notificationArray) {
                if (parseInt(record.ParentId, 10) === parseInt(activityObj.ID, 10)) {
                  if (record.Target === originalAssignedToUser.Email) {
                    this.deleteById(record.ID);
                  }
                }
              }
            } else {
              console.log('No notification configuration data was returned from server');
            }
          });
        } else {
          console.log('A valid email address is not available for the unassigned to user. Emails and notification functions will abort.');
        }

      } // if there is only an assigned to user
      else if (originalAssginedTo === '' && assignedTo !== '') {
        // Ensure that we have valid email
        if (assignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out assigned/unassigned to email
          /**** Post new notification*/
          if (mode === AppConstants.DELETE) {
            assignToEmailObj = this.createSendEmailObject(
              assignedToUser.Email,
              AppConstants.ACTIVITY_TYPE,
              AppConstants.UNASSIGN_TO,
              activityObj.Identifier,
              activityObj.ID,
              _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
              activityObj.Title,
              activityObj.Description);

            // Submit to AutoGeneratedEmailsOnDemandListItem SP list
            this.onDemandEmail.persist(assignToEmailObj);
          } else {
            assignToEmailObj = this.createSendEmailObject(
              assignedToUser.Email,
              AppConstants.ACTIVITY_TYPE,
              AppConstants.ASSIGN_TO,
              activityObj.Identifier,
              activityObj.ID,
              _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
              activityObj.Title,
              activityObj.Description);

            // Submit to AutoGeneratedEmailsOnDemandListItem SP list
            this.onDemandEmail.persist(assignToEmailObj);

            this.saveNotificationRecord(
              activityObj.ID,
              '',
              mode,
              AppConstants.ASSIGN_TO,
              AppConstants.ACTIVITY_TYPE, // TODO - need to make dynamic to support both activities and action items
              activityObj.Title,
              '', // there is no description for activities
              activityObj.Identifier,
              assignedToUser.Email);
          }

        } else {
          console.log('A valid email address is not available for the ASSIGN TO user. Emails and notification functions will abort.');
        }
      }
    }
  }

  /*** This method BOTH posts assigned to/unassigned records to the AutoGeneratedEmailsOnDemandList SP list and
   * adds/deletes notification records from the NotificationConfiguration SP list*/
  // TODO -   need to refine this method - if used during deletion of an action item
  //         it incorrectly sends out assign to email as opposed to unassign to email
  postEmailsAndAddOrDeleteNotificaitonsForActionItems(
    activityObj: any,
    actionItemObj: any,
    assignedTo: string,
    originalAssginedTo: string,
    mode: string): void {
    // If a user was assigned this task post to 'AutoGeneratedEmailsOnDemandList'
    if (actionItemObj) {

      let assignedToUser;
      let originalAssignedToUser;

      // standardize the this.originalAssignedToUser and assignedTo values
      if (originalAssginedTo === null || originalAssginedTo === undefined) {
        originalAssginedTo = '';
      }

      if (assignedTo === null || assignedTo === undefined) {
        assignedTo = '';
      }

      // If both the assigned to and the original assigned user values are empty there are no notifications that need to go out
      if (assignedTo === '') {
        if (originalAssginedTo === '') {
          return;
        }
      }

      if (assignedTo === originalAssginedTo) {
        return;
      }

      // Get email address target information for all users
      if (assignedTo !== '') {
        assignedToUser = this.siteAllUsers.value.find(item => item.Title.toLowerCase() === assignedTo.toLowerCase());
      }

      if (originalAssginedTo !== '') {
        originalAssignedToUser = this.siteAllUsers.value.find(item => item.Title.toLowerCase() === originalAssginedTo.toLowerCase());
      }

      let assignToEmailObj;
      let unassignEmailObj;

      // If there is both an unassign to and an assign to
      if (originalAssginedTo !== '' && assignedTo !== '') {
        // Ensure that we have valid emails for both
        if (originalAssignedToUser && assignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out assigned to email
          assignToEmailObj = this.createSendEmailObject(
            assignedToUser.Email,
            AppConstants.ACTION_ITEM_TYPE,
            AppConstants.ASSIGN_TO_ACTION_ITEM,
            activityObj.Identifier,
            actionItemObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + actionItemObj.ID + '&mode=edit',
            actionItemObj.title,
            actionItemObj.description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(assignToEmailObj);

          // send out unassigned to email
          unassignEmailObj = this.createSendEmailObject(
            originalAssignedToUser.Email,
            AppConstants.ACTION_ITEM_TYPE,
            AppConstants.UNASSIGN_TO_ACTION_ITEM,
            activityObj.Identifier,
            actionItemObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + actionItemObj.ID + '&mode=edit',
            actionItemObj.title,
            actionItemObj.description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(unassignEmailObj);

          /**** Post new notification and delete old*/

          // Post assign to notification
          this.saveNotificationRecord(
            actionItemObj.ID,
            '',
            mode,
            AppConstants.ASSIGN_TO_ACTION_ITEM,
            AppConstants.ACTION_ITEM_TYPE, // TODO - need to make dynamic to support both activities and action items
            actionItemObj.title,
            actionItemObj.description,
            activityObj.Identifier,
            assignedToUser.Email);

          // Remove old assigned to notification
          this.restAPIService.getNotificationConfiguration().subscribe((response) => {
            if (this.restAPIService.isSuccessResponse(response)) {
              let notificationArray = [];
              notificationArray = response.data;

              for (const record of notificationArray) {
                if (parseInt(record.ParentId, 10) === parseInt(actionItemObj.ID, 10)) {
                  if (record.Target === originalAssignedToUser.Email) {
                    this.deleteById(record.ID);
                  }
                }
              }
            } else {
              console.log('No notification configuration data was returned from server');
            }
          });
        } else {
          console.log('A valid email address is not available for both the ASSIGNED TO and UNASSIGNED TO users. Emails and notification functions will abort.');
        }
      } // if there is only an original assigned to user
      else if (originalAssginedTo !== '' && assignedTo === '') {
        // Ensure that we have valid email
        if (originalAssignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out unassigned to email
          unassignEmailObj = this.createSendEmailObject(
            originalAssignedToUser.Email,
            AppConstants.ACTION_ITEM_TYPE,
            AppConstants.UNASSIGN_TO_ACTION_ITEM,
            activityObj.Identifier,
            actionItemObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + actionItemObj.ID + '&mode=edit',
            actionItemObj.title,
            actionItemObj.description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(unassignEmailObj);

          /**** Delete old notification*/

          // Remove old assigned to notification
          this.restAPIService.getNotificationConfiguration().subscribe((response) => {
            if (this.restAPIService.isSuccessResponse(response)) {
              let notificationArray = [];
              notificationArray = response.data;

              for (const record of notificationArray) {
                if (parseInt(record.ParentId, 10) === parseInt(actionItemObj.ID, 10)) {
                  if (record.Target === originalAssignedToUser.Email) {
                    this.deleteById(record.ID);
                  }
                }
              }
            } else {
              console.log('No notification configuration data was returned from server');
            }
          });
        } else {
          console.log('A valid email address is not available for the unassigned to user. Emails and notification functions will abort.');
        }

      } // if there is only an assigned to user
      else if (originalAssginedTo === '' && assignedTo !== '') {
        // Ensure that we have valid email
        if (assignedToUser) {

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out assigned to email
          assignToEmailObj = this.createSendEmailObject(
            assignedToUser.Email,
            AppConstants.ACTION_ITEM_TYPE,
            AppConstants.ASSIGN_TO_ACTION_ITEM,
            activityObj.Identifier,
            actionItemObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + actionItemObj.ID + '&mode=edit',
            actionItemObj.title,
            actionItemObj.description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(assignToEmailObj);

          /**** Post new notification*/
          this.saveNotificationRecord(
            actionItemObj.ID,
            '',
            mode,
            AppConstants.ASSIGN_TO_ACTION_ITEM,
            AppConstants.ACTION_ITEM_TYPE, // TODO - need to make dynamic to support both activities and action items
            actionItemObj.title,
            activityObj.ProjectTitle,
            activityObj.Identifier,
            assignedToUser.Email);
        } else {
          console.log('A valid email address is not available for the ASSIGN TO user. Emails and notification functions will abort.');
        }
      }
    }
  }

  sendUnassignedToEmailForActionItem(
    activityObj: any,
    actionItemObj: any,
    assignedTo: string): void {
    // If a user was assigned this task post to 'AutoGeneratedEmailsOnDemandList'
    if (actionItemObj) {

      let assignedToUser;

      if (assignedTo === null || assignedTo === undefined) {
        assignedTo = '';
      }

      // If both the assigned to and the original assigned user values are empty there are no notifications that need to go out
      if (assignedTo === '') {
        console.log('Cannot send out unassign email for action item without Assign To information.');
        return;
      }

      // Get email address target information for all users
      if (assignedTo !== '') {
        assignedToUser = this.siteAllUsers.value.find(item => item.Title.toLowerCase() === assignedTo.toLowerCase());

        if (assignedToUser) {
          let unassignEmailObj;

          /**** Post AutoGeneratedEmailsOnDemand */

          // send out unassigned to email
          unassignEmailObj = this.createSendEmailObject(
            assignedToUser.Email,
            AppConstants.ACTION_ITEM_TYPE,
            AppConstants.UNASSIGN_TO_ACTION_ITEM,
            activityObj.Identifier,
            actionItemObj.ID,
            _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/action-item?actionItemId=' + actionItemObj.ID + '&mode=edit',
            actionItemObj.title,
            actionItemObj.description);

          // Submit to AutoGeneratedEmailsOnDemandListItem SP list
          this.onDemandEmail.persist(unassignEmailObj);

        } else {
          console.log('Could not get assigned to user information. Unassign email is aborted.');
        }
      }
    }
  }

  /***
   * parameters:
   * activityObj = activity object that this email is being sent out for
   * recipientsList = array wthe the following information per row of data: Email: 'bradfordk@seventhsenseconsulting.com' & Title: 'Kito Bradford'
   * recipient email address
   * emailType = indicates which type of Flow will be called on the backend to send out email
   */
  sendEmailForActivity(
    activityObj: any,
    recipientsList: any[],
    emailType: string,
    notificationIdentifier: string): void {

    if (activityObj && emailType && recipientsList.length > 0) {

      // Get email address target information for all users
      let targetString = '';
      if (recipientsList.length > 1) {
        for (const email of recipientsList) {
          targetString = targetString + email.Email + ',';
        }
      }
      else {
        targetString = recipientsList[0].Email.trim();
      }

      /**** Post AutoGeneratedEmailsOnDemand */

      // send out unassigned to email
      const emailObj = this.createSendEmailObject(
        targetString,
        AppConstants.ACTIVITY_TYPE,
        emailType,
        activityObj.Identifier,
        activityObj.ID,
        _spPageContextInfo.webAbsoluteUrl + '/SitePages/Home.aspx/activities/' + activityObj.ID + '?mode=edit',
        activityObj.Title,
        '');

      emailObj.ActivityType = activityObj.ActivityType;
      emailObj.NotificationIdentifier = notificationIdentifier;

      // Submit to AutoGeneratedEmailsOnDemandListItem SP list
      this.onDemandEmail.persist(emailObj);
    } else {
      console.log('activity object, emailType values, and recipientsList are required. Send out email function is aborted.');
    }
  }

  createSendEmailObject(
    email: string,
    itemType: string,
    title: string,
    contractNo: string,
    workItemId: number,
    URL: string,
    objectTitle: string,
    objectDescription: string): any {
    const sendEmailObj: any = {};
    sendEmailObj.RecipientsList = email;
    sendEmailObj.ItemType = itemType;
    sendEmailObj.NotificationIdentifier = '';
    sendEmailObj.__metadata = { type: 'SP.Data.AutoGeneratedEmailsOnDemandListItem' };
    sendEmailObj.Title = title;
    sendEmailObj.ContractNo = contractNo;
    sendEmailObj.WorkItemId = workItemId;
    sendEmailObj.URL = URL;
    sendEmailObj.ObjectTitle = objectTitle;
    sendEmailObj.ObjectDescription = objectDescription;
    return sendEmailObj;
  }

  // Core Notification Configuration SP list CRUD methods
  findOne(id: any): any { }

  findAll() { // NOTE: I can't use this because Javascript has no thread support
  }

  /*** Requires a valid notification object in order to successfully save */
  persist(object: any): any {
    if (!this.commonService.isNotUndefinedNullOrEmpty(object)) {
      console.log('Object is not valid, null, or empty. Aborting request.');
      return;
    }
    this.restAPIService.saveNotificationConfiguration(object).subscribe(response => {
      if (this.restAPIService.isSuccessResponse(response)) {
        console.log('The following notification configuration item was successfully saved the system:', response);
        // the following method only updates the notifications list
        this.restAPIService.notifyRefreshNotification();
        // the following method displays the in-app notification
        // this.toastr.warning(object.Title);
        if (object.Types === AppConstants.ASSIGN_TO ||
          object.Types === AppConstants.ASSIGN_TO_ACTION_ITEM) {
          this.toastr.warning(AppConstants.ASSIGN_TO_TEXT)
            .onTap
            .subscribe(() => this.toasterRedirectdHandler(object, object.ParentType, parseInt(object.ParentId, 10)));
        } else if (object.Types === AppConstants.PROCESS_PR_TO_CONTRACTS) {
          this.toastr.warning(AppConstants.PR_PCKG_APPROVAL)
            .onTap
            .subscribe(() => this.toasterRedirectdHandler(object, object.ParentType, parseInt(object.ParentId, 10)));
        } else if (object.Types === AppConstants.ACTION_REQUIRED) {
          this.toastr.warning(object.Title)
            .onTap
            .subscribe(() => this.toasterRedirectdHandler(object, object.ParentType, parseInt(object.ParentId, 10)));
        } else {
          this.toastr.warning(object.Title);
        }
      } else {
        console.log('findAll notification configuration API request was not successful.');
      }
    });
  }

  update(object: any): any { }

  delete(object: any): void { }

  deleteById(id: number): void {
    this.restAPIService.deleteNotificationConfiguration(id).subscribe(deleteResponse => {
      if (this.restAPIService.isSuccessResponse(deleteResponse)) {
        console.log('deleteById completed successfully and a Notification Configuration record with the following ID was deleted from the system: ', id);
        this.restAPIService.notifyRefreshNotification();
      } else {
        console.log('There was an error deleting a notification with the following id from the system: ', id);
      }
    });
  }

  getNotificationType(notificationType: string) {
    // TODO - Refactor this code so that we only make one API call to populate both a notification type list and an email template list
    // This way we don't have to make a million API calls everytime someone creates a notification object or sets the notification type
    if (this.commonService.isNotUndefinedNullOrEmpty(notificationType)) {
      this.restAPIService.getNotificationTypes().subscribe((responseObj: any) => {
        if (this.restAPIService.isSuccessResponse(responseObj)) {
          console.log('notificationTypeRes', responseObj);
          if (responseObj.data.length) {

            // Get notification type for activities
            this.notificationType = {};

            // const invoiceNotificationTypeData = [];
            for (const x of responseObj.data) {
              if (x.Types === notificationType) {
                this.notificationTypeData.push(x);
              }
            }

            if (this.notificationTypeData.length) {
              this.restAPIService.getEmailTemplateById(this.notificationTypeData[0].EmailTemplateID).subscribe((emailTemplateResp: any) => {
                if (this.restAPIService.isSuccessResponse(emailTemplateResp)) {
                  this.notificationType.notificationType = this.notificationTypeData[0].Types;
                  this.notificationType.subject = emailTemplateResp.data.Subject;
                  this.notificationType.message = emailTemplateResp.data.Description;
                  this.notificationType.notificationTypeID = this.notificationTypeData[0].ID;
                }
              });
            }
            else {
              console.log('No Notification type is found');
            }
          }
          else {
            console.log('notificationTypeRes no Data Found');
          }
        } else {
          console.log('Could not fetch the requested notification type from db', notificationType);
        }
      });
    } else {
      console.log('notificationType is empty. Aborting request.');
      return;
    }
  }

  toasterRedirectdHandler(notification, parentType: string, objectID: number) {
    console.log('Toastr clicked');
    if (
      this.commonService.isNotUndefinedNullOrEmpty(parentType) &&
      this.commonService.isNotUndefinedNullOrEmpty(objectID)) {
      if (parentType === AppConstants.ACTIVITY_TYPE) {
        this.router.navigate(['activities', objectID], { queryParams: { mode: 'edit' } });
      } else if (parentType === AppConstants.ACTION_ITEM_TYPE) {
        this.goToSource(notification, 'edit');
      }
      // TODO
      // Need to go in and add support for redirect of all notification types
    } else {
      console.log('On-click cannot be called since notification type, object parent type, or object id is undefined, null, or empty.');
    }
  }

  goToSource(notification, isEdit: string) {
    if (notification.ParentType === AppConstants.ACTIVITY_TYPE) {
      this.router.navigate(['activities', notification.ParentId], { queryParams: { mode: isEdit } });
    } else if (notification.ParentType === AppConstants.ACTION_ITEM_TYPE) {
      let siteAllUsers;
      this.restAPIService.getAllSiteUsers().subscribe((users: any) => {
        siteAllUsers = users.data;
      });
      forkJoin([this.restAPIService.getProjectsAsPerUserRole(null, AppConstants.SELECTED_FIELD_PROJECT),
      this.restAPIService.getActionItems(`ID eq '${notification.ParentId}'`)]).subscribe((responses: any[]) => {
        // this.restAPIService.getActivityById(notification.ParentId)]).subscribe((responses: any []) => {
        if (responses[0].data.length) {
          this.projects = [];
          for (const project of responses[0].data) {
            this.projects.push(project);
          }
        }

        // if (responses[1].data.length) {
        if (responses[1].data) {
          // Even though we requsted using the id - query comes back as a list need to get data at 0 from the list
          this.actionItem = responses[1].data[0];
          this.index = 0;

          // Now that we have the action item we also have the activity ID
          if (this.commonService.isNotUndefinedNullOrEmpty(this.actionItem.ParentId)) {
            this.restAPIService.getActivityById(this.actionItem.ParentId).subscribe((response: any) => {
              if (this.restAPIService.isSuccessResponse(response)) {
                this.restAPIService.getActionItems(`ParentId eq '${this.actionItem.ParentId}'`).subscribe((getAllActionItemsResponse: any) => {
                  if (this.restAPIService.isSuccessResponse(getAllActionItemsResponse)) {
                    this.actionItemsList = [];
                    this.actionItemsList = getAllActionItemsResponse.data;

                    const activity = response.data;
                    activity.ActivityFileNames = JSON.parse(activity.ActivityFileNames);
                    activity.TrackingItems = JSON.parse(activity.TrackingItems);

                    // Update project info in the activity
                    if (this.projects.length) {
                      for (const project of this.projects) {
                        if (project.Title.toLowerCase() === notification.ContractNo.toLowerCase()) {
                          // activity.project = project.contractNo;
                          activity.selectedProject = project;
                        }
                      }
                    }

                    // activity.Action

                    this.router.navigate(['action-item'], {
                      state: {
                        parentPageData: activity,
                        mode: isEdit,
                        projectParams: {},
                        parentPage: AppConstants.ACTIVITY_TYPE,
                        parentPageDataId: activity.ID,
                        activityActionItems: this.actionItemsList,
                        siteUsersList: siteAllUsers,
                        index: this.index,
                        actionItem: this.actionItem
                      }
                    });
                  }
                  else {
                    console.log('No Action Items found');
                  }
                });
              }
            });
          } else {
            console.log('Activity Id is not available in Action Item. Redirect will fail.');
          }
        }
      });
    }
  }
}
